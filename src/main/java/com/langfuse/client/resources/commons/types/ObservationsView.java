/**
 * This file was auto-generated by Fern from our API Definition.
 */

package com.langfuse.client.resources.commons.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.langfuse.client.core.Nullable;
import com.langfuse.client.core.NullableNonemptyFilter;
import com.langfuse.client.core.ObjectMappers;
import java.lang.Double;
import java.lang.Integer;
import java.lang.Object;
import java.lang.String;
import java.time.OffsetDateTime;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import org.jetbrains.annotations.NotNull;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(
    builder = ObservationsView.Builder.class
)
public final class ObservationsView implements IObservation {
  private final String id;

  private final Optional<String> traceId;

  private final String type;

  private final Optional<String> name;

  private final OffsetDateTime startTime;

  private final Optional<OffsetDateTime> endTime;

  private final Optional<OffsetDateTime> completionStartTime;

  private final Optional<String> model;

  private final Object modelParameters;

  private final Object input;

  private final Optional<String> version;

  private final Object metadata;

  private final Object output;

  private final Usage usage;

  private final ObservationLevel level;

  private final Optional<String> statusMessage;

  private final Optional<String> parentObservationId;

  private final Optional<String> promptId;

  private final Map<String, Integer> usageDetails;

  private final Map<String, Double> costDetails;

  private final String environment;

  private final Optional<String> promptName;

  private final Optional<Integer> promptVersion;

  private final Optional<String> modelId;

  private final Optional<Double> inputPrice;

  private final Optional<Double> outputPrice;

  private final Optional<Double> totalPrice;

  private final Optional<Double> calculatedInputCost;

  private final Optional<Double> calculatedOutputCost;

  private final Optional<Double> calculatedTotalCost;

  private final Optional<Double> latency;

  private final Optional<Double> timeToFirstToken;

  private final Map<String, Object> additionalProperties;

  private ObservationsView(String id, Optional<String> traceId, String type, Optional<String> name,
      OffsetDateTime startTime, Optional<OffsetDateTime> endTime,
      Optional<OffsetDateTime> completionStartTime, Optional<String> model, Object modelParameters,
      Object input, Optional<String> version, Object metadata, Object output, Usage usage,
      ObservationLevel level, Optional<String> statusMessage, Optional<String> parentObservationId,
      Optional<String> promptId, Map<String, Integer> usageDetails, Map<String, Double> costDetails,
      String environment, Optional<String> promptName, Optional<Integer> promptVersion,
      Optional<String> modelId, Optional<Double> inputPrice, Optional<Double> outputPrice,
      Optional<Double> totalPrice, Optional<Double> calculatedInputCost,
      Optional<Double> calculatedOutputCost, Optional<Double> calculatedTotalCost,
      Optional<Double> latency, Optional<Double> timeToFirstToken,
      Map<String, Object> additionalProperties) {
    this.id = id;
    this.traceId = traceId;
    this.type = type;
    this.name = name;
    this.startTime = startTime;
    this.endTime = endTime;
    this.completionStartTime = completionStartTime;
    this.model = model;
    this.modelParameters = modelParameters;
    this.input = input;
    this.version = version;
    this.metadata = metadata;
    this.output = output;
    this.usage = usage;
    this.level = level;
    this.statusMessage = statusMessage;
    this.parentObservationId = parentObservationId;
    this.promptId = promptId;
    this.usageDetails = usageDetails;
    this.costDetails = costDetails;
    this.environment = environment;
    this.promptName = promptName;
    this.promptVersion = promptVersion;
    this.modelId = modelId;
    this.inputPrice = inputPrice;
    this.outputPrice = outputPrice;
    this.totalPrice = totalPrice;
    this.calculatedInputCost = calculatedInputCost;
    this.calculatedOutputCost = calculatedOutputCost;
    this.calculatedTotalCost = calculatedTotalCost;
    this.latency = latency;
    this.timeToFirstToken = timeToFirstToken;
    this.additionalProperties = additionalProperties;
  }

  /**
   * @return The unique identifier of the observation
   */
  @JsonProperty("id")
  @java.lang.Override
  public String getId() {
    return id;
  }

  /**
   * @return The trace ID associated with the observation
   */
  @JsonIgnore
  @java.lang.Override
  public Optional<String> getTraceId() {
    if (traceId == null) {
      return Optional.empty();
    }
    return traceId;
  }

  /**
   * @return The type of the observation
   */
  @JsonProperty("type")
  @java.lang.Override
  public String getType() {
    return type;
  }

  /**
   * @return The name of the observation
   */
  @JsonIgnore
  @java.lang.Override
  public Optional<String> getName() {
    if (name == null) {
      return Optional.empty();
    }
    return name;
  }

  /**
   * @return The start time of the observation
   */
  @JsonProperty("startTime")
  @java.lang.Override
  public OffsetDateTime getStartTime() {
    return startTime;
  }

  /**
   * @return The end time of the observation.
   */
  @JsonIgnore
  @java.lang.Override
  public Optional<OffsetDateTime> getEndTime() {
    if (endTime == null) {
      return Optional.empty();
    }
    return endTime;
  }

  /**
   * @return The completion start time of the observation
   */
  @JsonIgnore
  @java.lang.Override
  public Optional<OffsetDateTime> getCompletionStartTime() {
    if (completionStartTime == null) {
      return Optional.empty();
    }
    return completionStartTime;
  }

  /**
   * @return The model used for the observation
   */
  @JsonIgnore
  @java.lang.Override
  public Optional<String> getModel() {
    if (model == null) {
      return Optional.empty();
    }
    return model;
  }

  /**
   * @return The parameters of the model used for the observation
   */
  @JsonProperty("modelParameters")
  @java.lang.Override
  public Object getModelParameters() {
    return modelParameters;
  }

  /**
   * @return The input data of the observation
   */
  @JsonProperty("input")
  @java.lang.Override
  public Object getInput() {
    return input;
  }

  /**
   * @return The version of the observation
   */
  @JsonIgnore
  @java.lang.Override
  public Optional<String> getVersion() {
    if (version == null) {
      return Optional.empty();
    }
    return version;
  }

  /**
   * @return Additional metadata of the observation
   */
  @JsonProperty("metadata")
  @java.lang.Override
  public Object getMetadata() {
    return metadata;
  }

  /**
   * @return The output data of the observation
   */
  @JsonProperty("output")
  @java.lang.Override
  public Object getOutput() {
    return output;
  }

  /**
   * @return (Deprecated. Use usageDetails and costDetails instead.) The usage data of the observation
   */
  @JsonProperty("usage")
  @java.lang.Override
  public Usage getUsage() {
    return usage;
  }

  /**
   * @return The level of the observation
   */
  @JsonProperty("level")
  @java.lang.Override
  public ObservationLevel getLevel() {
    return level;
  }

  /**
   * @return The status message of the observation
   */
  @JsonIgnore
  @java.lang.Override
  public Optional<String> getStatusMessage() {
    if (statusMessage == null) {
      return Optional.empty();
    }
    return statusMessage;
  }

  /**
   * @return The parent observation ID
   */
  @JsonIgnore
  @java.lang.Override
  public Optional<String> getParentObservationId() {
    if (parentObservationId == null) {
      return Optional.empty();
    }
    return parentObservationId;
  }

  /**
   * @return The prompt ID associated with the observation
   */
  @JsonIgnore
  @java.lang.Override
  public Optional<String> getPromptId() {
    if (promptId == null) {
      return Optional.empty();
    }
    return promptId;
  }

  /**
   * @return The usage details of the observation. Key is the name of the usage metric, value is the number of units consumed. The total key is the sum of all (non-total) usage metrics or the total value ingested.
   */
  @JsonProperty("usageDetails")
  @java.lang.Override
  public Map<String, Integer> getUsageDetails() {
    return usageDetails;
  }

  /**
   * @return The cost details of the observation. Key is the name of the cost metric, value is the cost in USD. The total key is the sum of all (non-total) cost metrics or the total value ingested.
   */
  @JsonProperty("costDetails")
  @java.lang.Override
  public Map<String, Double> getCostDetails() {
    return costDetails;
  }

  /**
   * @return The environment from which this observation originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
   */
  @JsonProperty("environment")
  @java.lang.Override
  public String getEnvironment() {
    return environment;
  }

  /**
   * @return The name of the prompt associated with the observation
   */
  @JsonIgnore
  public Optional<String> getPromptName() {
    if (promptName == null) {
      return Optional.empty();
    }
    return promptName;
  }

  /**
   * @return The version of the prompt associated with the observation
   */
  @JsonIgnore
  public Optional<Integer> getPromptVersion() {
    if (promptVersion == null) {
      return Optional.empty();
    }
    return promptVersion;
  }

  /**
   * @return The unique identifier of the model
   */
  @JsonIgnore
  public Optional<String> getModelId() {
    if (modelId == null) {
      return Optional.empty();
    }
    return modelId;
  }

  /**
   * @return The price of the input in USD
   */
  @JsonIgnore
  public Optional<Double> getInputPrice() {
    if (inputPrice == null) {
      return Optional.empty();
    }
    return inputPrice;
  }

  /**
   * @return The price of the output in USD.
   */
  @JsonIgnore
  public Optional<Double> getOutputPrice() {
    if (outputPrice == null) {
      return Optional.empty();
    }
    return outputPrice;
  }

  /**
   * @return The total price in USD.
   */
  @JsonIgnore
  public Optional<Double> getTotalPrice() {
    if (totalPrice == null) {
      return Optional.empty();
    }
    return totalPrice;
  }

  /**
   * @return (Deprecated. Use usageDetails and costDetails instead.) The calculated cost of the input in USD
   */
  @JsonIgnore
  public Optional<Double> getCalculatedInputCost() {
    if (calculatedInputCost == null) {
      return Optional.empty();
    }
    return calculatedInputCost;
  }

  /**
   * @return (Deprecated. Use usageDetails and costDetails instead.) The calculated cost of the output in USD
   */
  @JsonIgnore
  public Optional<Double> getCalculatedOutputCost() {
    if (calculatedOutputCost == null) {
      return Optional.empty();
    }
    return calculatedOutputCost;
  }

  /**
   * @return (Deprecated. Use usageDetails and costDetails instead.) The calculated total cost in USD
   */
  @JsonIgnore
  public Optional<Double> getCalculatedTotalCost() {
    if (calculatedTotalCost == null) {
      return Optional.empty();
    }
    return calculatedTotalCost;
  }

  /**
   * @return The latency in seconds.
   */
  @JsonIgnore
  public Optional<Double> getLatency() {
    if (latency == null) {
      return Optional.empty();
    }
    return latency;
  }

  /**
   * @return The time to the first token in seconds
   */
  @JsonIgnore
  public Optional<Double> getTimeToFirstToken() {
    if (timeToFirstToken == null) {
      return Optional.empty();
    }
    return timeToFirstToken;
  }

  @JsonInclude(
      value = JsonInclude.Include.CUSTOM,
      valueFilter = NullableNonemptyFilter.class
  )
  @JsonProperty("traceId")
  private Optional<String> _getTraceId() {
    return traceId;
  }

  @JsonInclude(
      value = JsonInclude.Include.CUSTOM,
      valueFilter = NullableNonemptyFilter.class
  )
  @JsonProperty("name")
  private Optional<String> _getName() {
    return name;
  }

  @JsonInclude(
      value = JsonInclude.Include.CUSTOM,
      valueFilter = NullableNonemptyFilter.class
  )
  @JsonProperty("endTime")
  private Optional<OffsetDateTime> _getEndTime() {
    return endTime;
  }

  @JsonInclude(
      value = JsonInclude.Include.CUSTOM,
      valueFilter = NullableNonemptyFilter.class
  )
  @JsonProperty("completionStartTime")
  private Optional<OffsetDateTime> _getCompletionStartTime() {
    return completionStartTime;
  }

  @JsonInclude(
      value = JsonInclude.Include.CUSTOM,
      valueFilter = NullableNonemptyFilter.class
  )
  @JsonProperty("model")
  private Optional<String> _getModel() {
    return model;
  }

  @JsonInclude(
      value = JsonInclude.Include.CUSTOM,
      valueFilter = NullableNonemptyFilter.class
  )
  @JsonProperty("version")
  private Optional<String> _getVersion() {
    return version;
  }

  @JsonInclude(
      value = JsonInclude.Include.CUSTOM,
      valueFilter = NullableNonemptyFilter.class
  )
  @JsonProperty("statusMessage")
  private Optional<String> _getStatusMessage() {
    return statusMessage;
  }

  @JsonInclude(
      value = JsonInclude.Include.CUSTOM,
      valueFilter = NullableNonemptyFilter.class
  )
  @JsonProperty("parentObservationId")
  private Optional<String> _getParentObservationId() {
    return parentObservationId;
  }

  @JsonInclude(
      value = JsonInclude.Include.CUSTOM,
      valueFilter = NullableNonemptyFilter.class
  )
  @JsonProperty("promptId")
  private Optional<String> _getPromptId() {
    return promptId;
  }

  @JsonInclude(
      value = JsonInclude.Include.CUSTOM,
      valueFilter = NullableNonemptyFilter.class
  )
  @JsonProperty("promptName")
  private Optional<String> _getPromptName() {
    return promptName;
  }

  @JsonInclude(
      value = JsonInclude.Include.CUSTOM,
      valueFilter = NullableNonemptyFilter.class
  )
  @JsonProperty("promptVersion")
  private Optional<Integer> _getPromptVersion() {
    return promptVersion;
  }

  @JsonInclude(
      value = JsonInclude.Include.CUSTOM,
      valueFilter = NullableNonemptyFilter.class
  )
  @JsonProperty("modelId")
  private Optional<String> _getModelId() {
    return modelId;
  }

  @JsonInclude(
      value = JsonInclude.Include.CUSTOM,
      valueFilter = NullableNonemptyFilter.class
  )
  @JsonProperty("inputPrice")
  private Optional<Double> _getInputPrice() {
    return inputPrice;
  }

  @JsonInclude(
      value = JsonInclude.Include.CUSTOM,
      valueFilter = NullableNonemptyFilter.class
  )
  @JsonProperty("outputPrice")
  private Optional<Double> _getOutputPrice() {
    return outputPrice;
  }

  @JsonInclude(
      value = JsonInclude.Include.CUSTOM,
      valueFilter = NullableNonemptyFilter.class
  )
  @JsonProperty("totalPrice")
  private Optional<Double> _getTotalPrice() {
    return totalPrice;
  }

  @JsonInclude(
      value = JsonInclude.Include.CUSTOM,
      valueFilter = NullableNonemptyFilter.class
  )
  @JsonProperty("calculatedInputCost")
  private Optional<Double> _getCalculatedInputCost() {
    return calculatedInputCost;
  }

  @JsonInclude(
      value = JsonInclude.Include.CUSTOM,
      valueFilter = NullableNonemptyFilter.class
  )
  @JsonProperty("calculatedOutputCost")
  private Optional<Double> _getCalculatedOutputCost() {
    return calculatedOutputCost;
  }

  @JsonInclude(
      value = JsonInclude.Include.CUSTOM,
      valueFilter = NullableNonemptyFilter.class
  )
  @JsonProperty("calculatedTotalCost")
  private Optional<Double> _getCalculatedTotalCost() {
    return calculatedTotalCost;
  }

  @JsonInclude(
      value = JsonInclude.Include.CUSTOM,
      valueFilter = NullableNonemptyFilter.class
  )
  @JsonProperty("latency")
  private Optional<Double> _getLatency() {
    return latency;
  }

  @JsonInclude(
      value = JsonInclude.Include.CUSTOM,
      valueFilter = NullableNonemptyFilter.class
  )
  @JsonProperty("timeToFirstToken")
  private Optional<Double> _getTimeToFirstToken() {
    return timeToFirstToken;
  }

  @java.lang.Override
  public boolean equals(Object other) {
    if (this == other) return true;
    return other instanceof ObservationsView && equalTo((ObservationsView) other);
  }

  @JsonAnyGetter
  public Map<String, Object> getAdditionalProperties() {
    return this.additionalProperties;
  }

  private boolean equalTo(ObservationsView other) {
    return id.equals(other.id) && traceId.equals(other.traceId) && type.equals(other.type) && name.equals(other.name) && startTime.equals(other.startTime) && endTime.equals(other.endTime) && completionStartTime.equals(other.completionStartTime) && model.equals(other.model) && modelParameters.equals(other.modelParameters) && input.equals(other.input) && version.equals(other.version) && metadata.equals(other.metadata) && output.equals(other.output) && usage.equals(other.usage) && level.equals(other.level) && statusMessage.equals(other.statusMessage) && parentObservationId.equals(other.parentObservationId) && promptId.equals(other.promptId) && usageDetails.equals(other.usageDetails) && costDetails.equals(other.costDetails) && environment.equals(other.environment) && promptName.equals(other.promptName) && promptVersion.equals(other.promptVersion) && modelId.equals(other.modelId) && inputPrice.equals(other.inputPrice) && outputPrice.equals(other.outputPrice) && totalPrice.equals(other.totalPrice) && calculatedInputCost.equals(other.calculatedInputCost) && calculatedOutputCost.equals(other.calculatedOutputCost) && calculatedTotalCost.equals(other.calculatedTotalCost) && latency.equals(other.latency) && timeToFirstToken.equals(other.timeToFirstToken);
  }

  @java.lang.Override
  public int hashCode() {
    return Objects.hash(this.id, this.traceId, this.type, this.name, this.startTime, this.endTime, this.completionStartTime, this.model, this.modelParameters, this.input, this.version, this.metadata, this.output, this.usage, this.level, this.statusMessage, this.parentObservationId, this.promptId, this.usageDetails, this.costDetails, this.environment, this.promptName, this.promptVersion, this.modelId, this.inputPrice, this.outputPrice, this.totalPrice, this.calculatedInputCost, this.calculatedOutputCost, this.calculatedTotalCost, this.latency, this.timeToFirstToken);
  }

  @java.lang.Override
  public String toString() {
    return ObjectMappers.stringify(this);
  }

  public static IdStage builder() {
    return new Builder();
  }

  public interface IdStage {
    /**
     * <p>The unique identifier of the observation</p>
     */
    TypeStage id(@NotNull String id);

    Builder from(ObservationsView other);
  }

  public interface TypeStage {
    /**
     * <p>The type of the observation</p>
     */
    StartTimeStage type(@NotNull String type);
  }

  public interface StartTimeStage {
    /**
     * <p>The start time of the observation</p>
     */
    ModelParametersStage startTime(@NotNull OffsetDateTime startTime);
  }

  public interface ModelParametersStage {
    /**
     * <p>The parameters of the model used for the observation</p>
     */
    InputStage modelParameters(Object modelParameters);
  }

  public interface InputStage {
    /**
     * <p>The input data of the observation</p>
     */
    MetadataStage input(Object input);
  }

  public interface MetadataStage {
    /**
     * <p>Additional metadata of the observation</p>
     */
    OutputStage metadata(Object metadata);
  }

  public interface OutputStage {
    /**
     * <p>The output data of the observation</p>
     */
    UsageStage output(Object output);
  }

  public interface UsageStage {
    /**
     * <p>(Deprecated. Use usageDetails and costDetails instead.) The usage data of the observation</p>
     */
    LevelStage usage(@NotNull Usage usage);
  }

  public interface LevelStage {
    /**
     * <p>The level of the observation</p>
     */
    EnvironmentStage level(@NotNull ObservationLevel level);
  }

  public interface EnvironmentStage {
    /**
     * <p>The environment from which this observation originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.</p>
     */
    _FinalStage environment(@NotNull String environment);
  }

  public interface _FinalStage {
    ObservationsView build();

    _FinalStage additionalProperty(String key, Object value);

    _FinalStage additionalProperties(Map<String, Object> additionalProperties);

    /**
     * <p>The trace ID associated with the observation</p>
     */
    _FinalStage traceId(Optional<String> traceId);

    _FinalStage traceId(String traceId);

    _FinalStage traceId(Nullable<String> traceId);

    /**
     * <p>The name of the observation</p>
     */
    _FinalStage name(Optional<String> name);

    _FinalStage name(String name);

    _FinalStage name(Nullable<String> name);

    /**
     * <p>The end time of the observation.</p>
     */
    _FinalStage endTime(Optional<OffsetDateTime> endTime);

    _FinalStage endTime(OffsetDateTime endTime);

    _FinalStage endTime(Nullable<OffsetDateTime> endTime);

    /**
     * <p>The completion start time of the observation</p>
     */
    _FinalStage completionStartTime(Optional<OffsetDateTime> completionStartTime);

    _FinalStage completionStartTime(OffsetDateTime completionStartTime);

    _FinalStage completionStartTime(Nullable<OffsetDateTime> completionStartTime);

    /**
     * <p>The model used for the observation</p>
     */
    _FinalStage model(Optional<String> model);

    _FinalStage model(String model);

    _FinalStage model(Nullable<String> model);

    /**
     * <p>The version of the observation</p>
     */
    _FinalStage version(Optional<String> version);

    _FinalStage version(String version);

    _FinalStage version(Nullable<String> version);

    /**
     * <p>The status message of the observation</p>
     */
    _FinalStage statusMessage(Optional<String> statusMessage);

    _FinalStage statusMessage(String statusMessage);

    _FinalStage statusMessage(Nullable<String> statusMessage);

    /**
     * <p>The parent observation ID</p>
     */
    _FinalStage parentObservationId(Optional<String> parentObservationId);

    _FinalStage parentObservationId(String parentObservationId);

    _FinalStage parentObservationId(Nullable<String> parentObservationId);

    /**
     * <p>The prompt ID associated with the observation</p>
     */
    _FinalStage promptId(Optional<String> promptId);

    _FinalStage promptId(String promptId);

    _FinalStage promptId(Nullable<String> promptId);

    /**
     * <p>The usage details of the observation. Key is the name of the usage metric, value is the number of units consumed. The total key is the sum of all (non-total) usage metrics or the total value ingested.</p>
     */
    _FinalStage usageDetails(Map<String, Integer> usageDetails);

    _FinalStage putAllUsageDetails(Map<String, Integer> usageDetails);

    _FinalStage usageDetails(String key, Integer value);

    /**
     * <p>The cost details of the observation. Key is the name of the cost metric, value is the cost in USD. The total key is the sum of all (non-total) cost metrics or the total value ingested.</p>
     */
    _FinalStage costDetails(Map<String, Double> costDetails);

    _FinalStage putAllCostDetails(Map<String, Double> costDetails);

    _FinalStage costDetails(String key, Double value);

    /**
     * <p>The name of the prompt associated with the observation</p>
     */
    _FinalStage promptName(Optional<String> promptName);

    _FinalStage promptName(String promptName);

    _FinalStage promptName(Nullable<String> promptName);

    /**
     * <p>The version of the prompt associated with the observation</p>
     */
    _FinalStage promptVersion(Optional<Integer> promptVersion);

    _FinalStage promptVersion(Integer promptVersion);

    _FinalStage promptVersion(Nullable<Integer> promptVersion);

    /**
     * <p>The unique identifier of the model</p>
     */
    _FinalStage modelId(Optional<String> modelId);

    _FinalStage modelId(String modelId);

    _FinalStage modelId(Nullable<String> modelId);

    /**
     * <p>The price of the input in USD</p>
     */
    _FinalStage inputPrice(Optional<Double> inputPrice);

    _FinalStage inputPrice(Double inputPrice);

    _FinalStage inputPrice(Nullable<Double> inputPrice);

    /**
     * <p>The price of the output in USD.</p>
     */
    _FinalStage outputPrice(Optional<Double> outputPrice);

    _FinalStage outputPrice(Double outputPrice);

    _FinalStage outputPrice(Nullable<Double> outputPrice);

    /**
     * <p>The total price in USD.</p>
     */
    _FinalStage totalPrice(Optional<Double> totalPrice);

    _FinalStage totalPrice(Double totalPrice);

    _FinalStage totalPrice(Nullable<Double> totalPrice);

    /**
     * <p>(Deprecated. Use usageDetails and costDetails instead.) The calculated cost of the input in USD</p>
     */
    _FinalStage calculatedInputCost(Optional<Double> calculatedInputCost);

    _FinalStage calculatedInputCost(Double calculatedInputCost);

    _FinalStage calculatedInputCost(Nullable<Double> calculatedInputCost);

    /**
     * <p>(Deprecated. Use usageDetails and costDetails instead.) The calculated cost of the output in USD</p>
     */
    _FinalStage calculatedOutputCost(Optional<Double> calculatedOutputCost);

    _FinalStage calculatedOutputCost(Double calculatedOutputCost);

    _FinalStage calculatedOutputCost(Nullable<Double> calculatedOutputCost);

    /**
     * <p>(Deprecated. Use usageDetails and costDetails instead.) The calculated total cost in USD</p>
     */
    _FinalStage calculatedTotalCost(Optional<Double> calculatedTotalCost);

    _FinalStage calculatedTotalCost(Double calculatedTotalCost);

    _FinalStage calculatedTotalCost(Nullable<Double> calculatedTotalCost);

    /**
     * <p>The latency in seconds.</p>
     */
    _FinalStage latency(Optional<Double> latency);

    _FinalStage latency(Double latency);

    _FinalStage latency(Nullable<Double> latency);

    /**
     * <p>The time to the first token in seconds</p>
     */
    _FinalStage timeToFirstToken(Optional<Double> timeToFirstToken);

    _FinalStage timeToFirstToken(Double timeToFirstToken);

    _FinalStage timeToFirstToken(Nullable<Double> timeToFirstToken);
  }

  @JsonIgnoreProperties(
      ignoreUnknown = true
  )
  public static final class Builder implements IdStage, TypeStage, StartTimeStage, ModelParametersStage, InputStage, MetadataStage, OutputStage, UsageStage, LevelStage, EnvironmentStage, _FinalStage {
    private String id;

    private String type;

    private OffsetDateTime startTime;

    private Object modelParameters;

    private Object input;

    private Object metadata;

    private Object output;

    private Usage usage;

    private ObservationLevel level;

    private String environment;

    private Optional<Double> timeToFirstToken = Optional.empty();

    private Optional<Double> latency = Optional.empty();

    private Optional<Double> calculatedTotalCost = Optional.empty();

    private Optional<Double> calculatedOutputCost = Optional.empty();

    private Optional<Double> calculatedInputCost = Optional.empty();

    private Optional<Double> totalPrice = Optional.empty();

    private Optional<Double> outputPrice = Optional.empty();

    private Optional<Double> inputPrice = Optional.empty();

    private Optional<String> modelId = Optional.empty();

    private Optional<Integer> promptVersion = Optional.empty();

    private Optional<String> promptName = Optional.empty();

    private Map<String, Double> costDetails = new LinkedHashMap<>();

    private Map<String, Integer> usageDetails = new LinkedHashMap<>();

    private Optional<String> promptId = Optional.empty();

    private Optional<String> parentObservationId = Optional.empty();

    private Optional<String> statusMessage = Optional.empty();

    private Optional<String> version = Optional.empty();

    private Optional<String> model = Optional.empty();

    private Optional<OffsetDateTime> completionStartTime = Optional.empty();

    private Optional<OffsetDateTime> endTime = Optional.empty();

    private Optional<String> name = Optional.empty();

    private Optional<String> traceId = Optional.empty();

    @JsonAnySetter
    private Map<String, Object> additionalProperties = new HashMap<>();

    private Builder() {
    }

    @java.lang.Override
    public Builder from(ObservationsView other) {
      id(other.getId());
      traceId(other.getTraceId());
      type(other.getType());
      name(other.getName());
      startTime(other.getStartTime());
      endTime(other.getEndTime());
      completionStartTime(other.getCompletionStartTime());
      model(other.getModel());
      modelParameters(other.getModelParameters());
      input(other.getInput());
      version(other.getVersion());
      metadata(other.getMetadata());
      output(other.getOutput());
      usage(other.getUsage());
      level(other.getLevel());
      statusMessage(other.getStatusMessage());
      parentObservationId(other.getParentObservationId());
      promptId(other.getPromptId());
      usageDetails(other.getUsageDetails());
      costDetails(other.getCostDetails());
      environment(other.getEnvironment());
      promptName(other.getPromptName());
      promptVersion(other.getPromptVersion());
      modelId(other.getModelId());
      inputPrice(other.getInputPrice());
      outputPrice(other.getOutputPrice());
      totalPrice(other.getTotalPrice());
      calculatedInputCost(other.getCalculatedInputCost());
      calculatedOutputCost(other.getCalculatedOutputCost());
      calculatedTotalCost(other.getCalculatedTotalCost());
      latency(other.getLatency());
      timeToFirstToken(other.getTimeToFirstToken());
      return this;
    }

    /**
     * <p>The unique identifier of the observation</p>
     * <p>The unique identifier of the observation</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    @JsonSetter("id")
    public TypeStage id(@NotNull String id) {
      this.id = Objects.requireNonNull(id, "id must not be null");
      return this;
    }

    /**
     * <p>The type of the observation</p>
     * <p>The type of the observation</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    @JsonSetter("type")
    public StartTimeStage type(@NotNull String type) {
      this.type = Objects.requireNonNull(type, "type must not be null");
      return this;
    }

    /**
     * <p>The start time of the observation</p>
     * <p>The start time of the observation</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    @JsonSetter("startTime")
    public ModelParametersStage startTime(@NotNull OffsetDateTime startTime) {
      this.startTime = Objects.requireNonNull(startTime, "startTime must not be null");
      return this;
    }

    /**
     * <p>The parameters of the model used for the observation</p>
     * <p>The parameters of the model used for the observation</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    @JsonSetter("modelParameters")
    public InputStage modelParameters(Object modelParameters) {
      this.modelParameters = modelParameters;
      return this;
    }

    /**
     * <p>The input data of the observation</p>
     * <p>The input data of the observation</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    @JsonSetter("input")
    public MetadataStage input(Object input) {
      this.input = input;
      return this;
    }

    /**
     * <p>Additional metadata of the observation</p>
     * <p>Additional metadata of the observation</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    @JsonSetter("metadata")
    public OutputStage metadata(Object metadata) {
      this.metadata = metadata;
      return this;
    }

    /**
     * <p>The output data of the observation</p>
     * <p>The output data of the observation</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    @JsonSetter("output")
    public UsageStage output(Object output) {
      this.output = output;
      return this;
    }

    /**
     * <p>(Deprecated. Use usageDetails and costDetails instead.) The usage data of the observation</p>
     * <p>(Deprecated. Use usageDetails and costDetails instead.) The usage data of the observation</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    @JsonSetter("usage")
    public LevelStage usage(@NotNull Usage usage) {
      this.usage = Objects.requireNonNull(usage, "usage must not be null");
      return this;
    }

    /**
     * <p>The level of the observation</p>
     * <p>The level of the observation</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    @JsonSetter("level")
    public EnvironmentStage level(@NotNull ObservationLevel level) {
      this.level = Objects.requireNonNull(level, "level must not be null");
      return this;
    }

    /**
     * <p>The environment from which this observation originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.</p>
     * <p>The environment from which this observation originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    @JsonSetter("environment")
    public _FinalStage environment(@NotNull String environment) {
      this.environment = Objects.requireNonNull(environment, "environment must not be null");
      return this;
    }

    /**
     * <p>The time to the first token in seconds</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage timeToFirstToken(Nullable<Double> timeToFirstToken) {
      if (timeToFirstToken.isNull()) {
        this.timeToFirstToken = null;
      }
      else if (timeToFirstToken.isEmpty()) {
        this.timeToFirstToken = Optional.empty();
      }
      else {
        this.timeToFirstToken = Optional.of(timeToFirstToken.get());
      }
      return this;
    }

    /**
     * <p>The time to the first token in seconds</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage timeToFirstToken(Double timeToFirstToken) {
      this.timeToFirstToken = Optional.ofNullable(timeToFirstToken);
      return this;
    }

    /**
     * <p>The time to the first token in seconds</p>
     */
    @java.lang.Override
    @JsonSetter(
        value = "timeToFirstToken",
        nulls = Nulls.SKIP
    )
    public _FinalStage timeToFirstToken(Optional<Double> timeToFirstToken) {
      this.timeToFirstToken = timeToFirstToken;
      return this;
    }

    /**
     * <p>The latency in seconds.</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage latency(Nullable<Double> latency) {
      if (latency.isNull()) {
        this.latency = null;
      }
      else if (latency.isEmpty()) {
        this.latency = Optional.empty();
      }
      else {
        this.latency = Optional.of(latency.get());
      }
      return this;
    }

    /**
     * <p>The latency in seconds.</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage latency(Double latency) {
      this.latency = Optional.ofNullable(latency);
      return this;
    }

    /**
     * <p>The latency in seconds.</p>
     */
    @java.lang.Override
    @JsonSetter(
        value = "latency",
        nulls = Nulls.SKIP
    )
    public _FinalStage latency(Optional<Double> latency) {
      this.latency = latency;
      return this;
    }

    /**
     * <p>(Deprecated. Use usageDetails and costDetails instead.) The calculated total cost in USD</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage calculatedTotalCost(Nullable<Double> calculatedTotalCost) {
      if (calculatedTotalCost.isNull()) {
        this.calculatedTotalCost = null;
      }
      else if (calculatedTotalCost.isEmpty()) {
        this.calculatedTotalCost = Optional.empty();
      }
      else {
        this.calculatedTotalCost = Optional.of(calculatedTotalCost.get());
      }
      return this;
    }

    /**
     * <p>(Deprecated. Use usageDetails and costDetails instead.) The calculated total cost in USD</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage calculatedTotalCost(Double calculatedTotalCost) {
      this.calculatedTotalCost = Optional.ofNullable(calculatedTotalCost);
      return this;
    }

    /**
     * <p>(Deprecated. Use usageDetails and costDetails instead.) The calculated total cost in USD</p>
     */
    @java.lang.Override
    @JsonSetter(
        value = "calculatedTotalCost",
        nulls = Nulls.SKIP
    )
    public _FinalStage calculatedTotalCost(Optional<Double> calculatedTotalCost) {
      this.calculatedTotalCost = calculatedTotalCost;
      return this;
    }

    /**
     * <p>(Deprecated. Use usageDetails and costDetails instead.) The calculated cost of the output in USD</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage calculatedOutputCost(Nullable<Double> calculatedOutputCost) {
      if (calculatedOutputCost.isNull()) {
        this.calculatedOutputCost = null;
      }
      else if (calculatedOutputCost.isEmpty()) {
        this.calculatedOutputCost = Optional.empty();
      }
      else {
        this.calculatedOutputCost = Optional.of(calculatedOutputCost.get());
      }
      return this;
    }

    /**
     * <p>(Deprecated. Use usageDetails and costDetails instead.) The calculated cost of the output in USD</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage calculatedOutputCost(Double calculatedOutputCost) {
      this.calculatedOutputCost = Optional.ofNullable(calculatedOutputCost);
      return this;
    }

    /**
     * <p>(Deprecated. Use usageDetails and costDetails instead.) The calculated cost of the output in USD</p>
     */
    @java.lang.Override
    @JsonSetter(
        value = "calculatedOutputCost",
        nulls = Nulls.SKIP
    )
    public _FinalStage calculatedOutputCost(Optional<Double> calculatedOutputCost) {
      this.calculatedOutputCost = calculatedOutputCost;
      return this;
    }

    /**
     * <p>(Deprecated. Use usageDetails and costDetails instead.) The calculated cost of the input in USD</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage calculatedInputCost(Nullable<Double> calculatedInputCost) {
      if (calculatedInputCost.isNull()) {
        this.calculatedInputCost = null;
      }
      else if (calculatedInputCost.isEmpty()) {
        this.calculatedInputCost = Optional.empty();
      }
      else {
        this.calculatedInputCost = Optional.of(calculatedInputCost.get());
      }
      return this;
    }

    /**
     * <p>(Deprecated. Use usageDetails and costDetails instead.) The calculated cost of the input in USD</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage calculatedInputCost(Double calculatedInputCost) {
      this.calculatedInputCost = Optional.ofNullable(calculatedInputCost);
      return this;
    }

    /**
     * <p>(Deprecated. Use usageDetails and costDetails instead.) The calculated cost of the input in USD</p>
     */
    @java.lang.Override
    @JsonSetter(
        value = "calculatedInputCost",
        nulls = Nulls.SKIP
    )
    public _FinalStage calculatedInputCost(Optional<Double> calculatedInputCost) {
      this.calculatedInputCost = calculatedInputCost;
      return this;
    }

    /**
     * <p>The total price in USD.</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage totalPrice(Nullable<Double> totalPrice) {
      if (totalPrice.isNull()) {
        this.totalPrice = null;
      }
      else if (totalPrice.isEmpty()) {
        this.totalPrice = Optional.empty();
      }
      else {
        this.totalPrice = Optional.of(totalPrice.get());
      }
      return this;
    }

    /**
     * <p>The total price in USD.</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage totalPrice(Double totalPrice) {
      this.totalPrice = Optional.ofNullable(totalPrice);
      return this;
    }

    /**
     * <p>The total price in USD.</p>
     */
    @java.lang.Override
    @JsonSetter(
        value = "totalPrice",
        nulls = Nulls.SKIP
    )
    public _FinalStage totalPrice(Optional<Double> totalPrice) {
      this.totalPrice = totalPrice;
      return this;
    }

    /**
     * <p>The price of the output in USD.</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage outputPrice(Nullable<Double> outputPrice) {
      if (outputPrice.isNull()) {
        this.outputPrice = null;
      }
      else if (outputPrice.isEmpty()) {
        this.outputPrice = Optional.empty();
      }
      else {
        this.outputPrice = Optional.of(outputPrice.get());
      }
      return this;
    }

    /**
     * <p>The price of the output in USD.</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage outputPrice(Double outputPrice) {
      this.outputPrice = Optional.ofNullable(outputPrice);
      return this;
    }

    /**
     * <p>The price of the output in USD.</p>
     */
    @java.lang.Override
    @JsonSetter(
        value = "outputPrice",
        nulls = Nulls.SKIP
    )
    public _FinalStage outputPrice(Optional<Double> outputPrice) {
      this.outputPrice = outputPrice;
      return this;
    }

    /**
     * <p>The price of the input in USD</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage inputPrice(Nullable<Double> inputPrice) {
      if (inputPrice.isNull()) {
        this.inputPrice = null;
      }
      else if (inputPrice.isEmpty()) {
        this.inputPrice = Optional.empty();
      }
      else {
        this.inputPrice = Optional.of(inputPrice.get());
      }
      return this;
    }

    /**
     * <p>The price of the input in USD</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage inputPrice(Double inputPrice) {
      this.inputPrice = Optional.ofNullable(inputPrice);
      return this;
    }

    /**
     * <p>The price of the input in USD</p>
     */
    @java.lang.Override
    @JsonSetter(
        value = "inputPrice",
        nulls = Nulls.SKIP
    )
    public _FinalStage inputPrice(Optional<Double> inputPrice) {
      this.inputPrice = inputPrice;
      return this;
    }

    /**
     * <p>The unique identifier of the model</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage modelId(Nullable<String> modelId) {
      if (modelId.isNull()) {
        this.modelId = null;
      }
      else if (modelId.isEmpty()) {
        this.modelId = Optional.empty();
      }
      else {
        this.modelId = Optional.of(modelId.get());
      }
      return this;
    }

    /**
     * <p>The unique identifier of the model</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage modelId(String modelId) {
      this.modelId = Optional.ofNullable(modelId);
      return this;
    }

    /**
     * <p>The unique identifier of the model</p>
     */
    @java.lang.Override
    @JsonSetter(
        value = "modelId",
        nulls = Nulls.SKIP
    )
    public _FinalStage modelId(Optional<String> modelId) {
      this.modelId = modelId;
      return this;
    }

    /**
     * <p>The version of the prompt associated with the observation</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage promptVersion(Nullable<Integer> promptVersion) {
      if (promptVersion.isNull()) {
        this.promptVersion = null;
      }
      else if (promptVersion.isEmpty()) {
        this.promptVersion = Optional.empty();
      }
      else {
        this.promptVersion = Optional.of(promptVersion.get());
      }
      return this;
    }

    /**
     * <p>The version of the prompt associated with the observation</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage promptVersion(Integer promptVersion) {
      this.promptVersion = Optional.ofNullable(promptVersion);
      return this;
    }

    /**
     * <p>The version of the prompt associated with the observation</p>
     */
    @java.lang.Override
    @JsonSetter(
        value = "promptVersion",
        nulls = Nulls.SKIP
    )
    public _FinalStage promptVersion(Optional<Integer> promptVersion) {
      this.promptVersion = promptVersion;
      return this;
    }

    /**
     * <p>The name of the prompt associated with the observation</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage promptName(Nullable<String> promptName) {
      if (promptName.isNull()) {
        this.promptName = null;
      }
      else if (promptName.isEmpty()) {
        this.promptName = Optional.empty();
      }
      else {
        this.promptName = Optional.of(promptName.get());
      }
      return this;
    }

    /**
     * <p>The name of the prompt associated with the observation</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage promptName(String promptName) {
      this.promptName = Optional.ofNullable(promptName);
      return this;
    }

    /**
     * <p>The name of the prompt associated with the observation</p>
     */
    @java.lang.Override
    @JsonSetter(
        value = "promptName",
        nulls = Nulls.SKIP
    )
    public _FinalStage promptName(Optional<String> promptName) {
      this.promptName = promptName;
      return this;
    }

    /**
     * <p>The cost details of the observation. Key is the name of the cost metric, value is the cost in USD. The total key is the sum of all (non-total) cost metrics or the total value ingested.</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage costDetails(String key, Double value) {
      this.costDetails.put(key, value);
      return this;
    }

    /**
     * <p>The cost details of the observation. Key is the name of the cost metric, value is the cost in USD. The total key is the sum of all (non-total) cost metrics or the total value ingested.</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage putAllCostDetails(Map<String, Double> costDetails) {
      if (costDetails != null) {
        this.costDetails.putAll(costDetails);
      }
      return this;
    }

    /**
     * <p>The cost details of the observation. Key is the name of the cost metric, value is the cost in USD. The total key is the sum of all (non-total) cost metrics or the total value ingested.</p>
     */
    @java.lang.Override
    @JsonSetter(
        value = "costDetails",
        nulls = Nulls.SKIP
    )
    public _FinalStage costDetails(Map<String, Double> costDetails) {
      this.costDetails.clear();
      if (costDetails != null) {
        this.costDetails.putAll(costDetails);
      }
      return this;
    }

    /**
     * <p>The usage details of the observation. Key is the name of the usage metric, value is the number of units consumed. The total key is the sum of all (non-total) usage metrics or the total value ingested.</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage usageDetails(String key, Integer value) {
      this.usageDetails.put(key, value);
      return this;
    }

    /**
     * <p>The usage details of the observation. Key is the name of the usage metric, value is the number of units consumed. The total key is the sum of all (non-total) usage metrics or the total value ingested.</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage putAllUsageDetails(Map<String, Integer> usageDetails) {
      if (usageDetails != null) {
        this.usageDetails.putAll(usageDetails);
      }
      return this;
    }

    /**
     * <p>The usage details of the observation. Key is the name of the usage metric, value is the number of units consumed. The total key is the sum of all (non-total) usage metrics or the total value ingested.</p>
     */
    @java.lang.Override
    @JsonSetter(
        value = "usageDetails",
        nulls = Nulls.SKIP
    )
    public _FinalStage usageDetails(Map<String, Integer> usageDetails) {
      this.usageDetails.clear();
      if (usageDetails != null) {
        this.usageDetails.putAll(usageDetails);
      }
      return this;
    }

    /**
     * <p>The prompt ID associated with the observation</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage promptId(Nullable<String> promptId) {
      if (promptId.isNull()) {
        this.promptId = null;
      }
      else if (promptId.isEmpty()) {
        this.promptId = Optional.empty();
      }
      else {
        this.promptId = Optional.of(promptId.get());
      }
      return this;
    }

    /**
     * <p>The prompt ID associated with the observation</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage promptId(String promptId) {
      this.promptId = Optional.ofNullable(promptId);
      return this;
    }

    /**
     * <p>The prompt ID associated with the observation</p>
     */
    @java.lang.Override
    @JsonSetter(
        value = "promptId",
        nulls = Nulls.SKIP
    )
    public _FinalStage promptId(Optional<String> promptId) {
      this.promptId = promptId;
      return this;
    }

    /**
     * <p>The parent observation ID</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage parentObservationId(Nullable<String> parentObservationId) {
      if (parentObservationId.isNull()) {
        this.parentObservationId = null;
      }
      else if (parentObservationId.isEmpty()) {
        this.parentObservationId = Optional.empty();
      }
      else {
        this.parentObservationId = Optional.of(parentObservationId.get());
      }
      return this;
    }

    /**
     * <p>The parent observation ID</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage parentObservationId(String parentObservationId) {
      this.parentObservationId = Optional.ofNullable(parentObservationId);
      return this;
    }

    /**
     * <p>The parent observation ID</p>
     */
    @java.lang.Override
    @JsonSetter(
        value = "parentObservationId",
        nulls = Nulls.SKIP
    )
    public _FinalStage parentObservationId(Optional<String> parentObservationId) {
      this.parentObservationId = parentObservationId;
      return this;
    }

    /**
     * <p>The status message of the observation</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage statusMessage(Nullable<String> statusMessage) {
      if (statusMessage.isNull()) {
        this.statusMessage = null;
      }
      else if (statusMessage.isEmpty()) {
        this.statusMessage = Optional.empty();
      }
      else {
        this.statusMessage = Optional.of(statusMessage.get());
      }
      return this;
    }

    /**
     * <p>The status message of the observation</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage statusMessage(String statusMessage) {
      this.statusMessage = Optional.ofNullable(statusMessage);
      return this;
    }

    /**
     * <p>The status message of the observation</p>
     */
    @java.lang.Override
    @JsonSetter(
        value = "statusMessage",
        nulls = Nulls.SKIP
    )
    public _FinalStage statusMessage(Optional<String> statusMessage) {
      this.statusMessage = statusMessage;
      return this;
    }

    /**
     * <p>The version of the observation</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage version(Nullable<String> version) {
      if (version.isNull()) {
        this.version = null;
      }
      else if (version.isEmpty()) {
        this.version = Optional.empty();
      }
      else {
        this.version = Optional.of(version.get());
      }
      return this;
    }

    /**
     * <p>The version of the observation</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage version(String version) {
      this.version = Optional.ofNullable(version);
      return this;
    }

    /**
     * <p>The version of the observation</p>
     */
    @java.lang.Override
    @JsonSetter(
        value = "version",
        nulls = Nulls.SKIP
    )
    public _FinalStage version(Optional<String> version) {
      this.version = version;
      return this;
    }

    /**
     * <p>The model used for the observation</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage model(Nullable<String> model) {
      if (model.isNull()) {
        this.model = null;
      }
      else if (model.isEmpty()) {
        this.model = Optional.empty();
      }
      else {
        this.model = Optional.of(model.get());
      }
      return this;
    }

    /**
     * <p>The model used for the observation</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage model(String model) {
      this.model = Optional.ofNullable(model);
      return this;
    }

    /**
     * <p>The model used for the observation</p>
     */
    @java.lang.Override
    @JsonSetter(
        value = "model",
        nulls = Nulls.SKIP
    )
    public _FinalStage model(Optional<String> model) {
      this.model = model;
      return this;
    }

    /**
     * <p>The completion start time of the observation</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage completionStartTime(Nullable<OffsetDateTime> completionStartTime) {
      if (completionStartTime.isNull()) {
        this.completionStartTime = null;
      }
      else if (completionStartTime.isEmpty()) {
        this.completionStartTime = Optional.empty();
      }
      else {
        this.completionStartTime = Optional.of(completionStartTime.get());
      }
      return this;
    }

    /**
     * <p>The completion start time of the observation</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage completionStartTime(OffsetDateTime completionStartTime) {
      this.completionStartTime = Optional.ofNullable(completionStartTime);
      return this;
    }

    /**
     * <p>The completion start time of the observation</p>
     */
    @java.lang.Override
    @JsonSetter(
        value = "completionStartTime",
        nulls = Nulls.SKIP
    )
    public _FinalStage completionStartTime(Optional<OffsetDateTime> completionStartTime) {
      this.completionStartTime = completionStartTime;
      return this;
    }

    /**
     * <p>The end time of the observation.</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage endTime(Nullable<OffsetDateTime> endTime) {
      if (endTime.isNull()) {
        this.endTime = null;
      }
      else if (endTime.isEmpty()) {
        this.endTime = Optional.empty();
      }
      else {
        this.endTime = Optional.of(endTime.get());
      }
      return this;
    }

    /**
     * <p>The end time of the observation.</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage endTime(OffsetDateTime endTime) {
      this.endTime = Optional.ofNullable(endTime);
      return this;
    }

    /**
     * <p>The end time of the observation.</p>
     */
    @java.lang.Override
    @JsonSetter(
        value = "endTime",
        nulls = Nulls.SKIP
    )
    public _FinalStage endTime(Optional<OffsetDateTime> endTime) {
      this.endTime = endTime;
      return this;
    }

    /**
     * <p>The name of the observation</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage name(Nullable<String> name) {
      if (name.isNull()) {
        this.name = null;
      }
      else if (name.isEmpty()) {
        this.name = Optional.empty();
      }
      else {
        this.name = Optional.of(name.get());
      }
      return this;
    }

    /**
     * <p>The name of the observation</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage name(String name) {
      this.name = Optional.ofNullable(name);
      return this;
    }

    /**
     * <p>The name of the observation</p>
     */
    @java.lang.Override
    @JsonSetter(
        value = "name",
        nulls = Nulls.SKIP
    )
    public _FinalStage name(Optional<String> name) {
      this.name = name;
      return this;
    }

    /**
     * <p>The trace ID associated with the observation</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage traceId(Nullable<String> traceId) {
      if (traceId.isNull()) {
        this.traceId = null;
      }
      else if (traceId.isEmpty()) {
        this.traceId = Optional.empty();
      }
      else {
        this.traceId = Optional.of(traceId.get());
      }
      return this;
    }

    /**
     * <p>The trace ID associated with the observation</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    public _FinalStage traceId(String traceId) {
      this.traceId = Optional.ofNullable(traceId);
      return this;
    }

    /**
     * <p>The trace ID associated with the observation</p>
     */
    @java.lang.Override
    @JsonSetter(
        value = "traceId",
        nulls = Nulls.SKIP
    )
    public _FinalStage traceId(Optional<String> traceId) {
      this.traceId = traceId;
      return this;
    }

    @java.lang.Override
    public ObservationsView build() {
      return new ObservationsView(id, traceId, type, name, startTime, endTime, completionStartTime, model, modelParameters, input, version, metadata, output, usage, level, statusMessage, parentObservationId, promptId, usageDetails, costDetails, environment, promptName, promptVersion, modelId, inputPrice, outputPrice, totalPrice, calculatedInputCost, calculatedOutputCost, calculatedTotalCost, latency, timeToFirstToken, additionalProperties);
    }

    @java.lang.Override
    public Builder additionalProperty(String key, Object value) {
      this.additionalProperties.put(key, value);
      return this;
    }

    @java.lang.Override
    public Builder additionalProperties(Map<String, Object> additionalProperties) {
      this.additionalProperties.putAll(additionalProperties);
      return this;
    }
  }
}
