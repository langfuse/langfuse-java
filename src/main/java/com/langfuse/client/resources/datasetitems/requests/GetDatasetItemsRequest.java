/**
 * This file was auto-generated by Fern from our API Definition.
 */

package com.langfuse.client.resources.datasetitems.requests;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.langfuse.client.core.ObjectMappers;
import java.lang.Integer;
import java.lang.Object;
import java.lang.String;
import java.time.OffsetDateTime;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(
    builder = GetDatasetItemsRequest.Builder.class
)
public final class GetDatasetItemsRequest {
  private final Optional<String> datasetName;

  private final Optional<String> sourceTraceId;

  private final Optional<String> sourceObservationId;

  private final Optional<OffsetDateTime> version;

  private final Optional<Integer> page;

  private final Optional<Integer> limit;

  private final Map<String, Object> additionalProperties;

  private GetDatasetItemsRequest(Optional<String> datasetName, Optional<String> sourceTraceId,
      Optional<String> sourceObservationId, Optional<OffsetDateTime> version,
      Optional<Integer> page, Optional<Integer> limit, Map<String, Object> additionalProperties) {
    this.datasetName = datasetName;
    this.sourceTraceId = sourceTraceId;
    this.sourceObservationId = sourceObservationId;
    this.version = version;
    this.page = page;
    this.limit = limit;
    this.additionalProperties = additionalProperties;
  }

  @JsonProperty("datasetName")
  public Optional<String> getDatasetName() {
    return datasetName;
  }

  @JsonProperty("sourceTraceId")
  public Optional<String> getSourceTraceId() {
    return sourceTraceId;
  }

  @JsonProperty("sourceObservationId")
  public Optional<String> getSourceObservationId() {
    return sourceObservationId;
  }

  /**
   * @return ISO 8601 timestamp (RFC 3339, Section 5.6) in UTC (e.g., &quot;2026-01-21T14:35:42Z&quot;).
   * If provided, returns state of dataset at this timestamp.
   * If not provided, returns the latest version. Requires datasetName to be specified.
   */
  @JsonProperty("version")
  public Optional<OffsetDateTime> getVersion() {
    return version;
  }

  /**
   * @return page number, starts at 1
   */
  @JsonProperty("page")
  public Optional<Integer> getPage() {
    return page;
  }

  /**
   * @return limit of items per page
   */
  @JsonProperty("limit")
  public Optional<Integer> getLimit() {
    return limit;
  }

  @java.lang.Override
  public boolean equals(Object other) {
    if (this == other) return true;
    return other instanceof GetDatasetItemsRequest && equalTo((GetDatasetItemsRequest) other);
  }

  @JsonAnyGetter
  public Map<String, Object> getAdditionalProperties() {
    return this.additionalProperties;
  }

  private boolean equalTo(GetDatasetItemsRequest other) {
    return datasetName.equals(other.datasetName) && sourceTraceId.equals(other.sourceTraceId) && sourceObservationId.equals(other.sourceObservationId) && version.equals(other.version) && page.equals(other.page) && limit.equals(other.limit);
  }

  @java.lang.Override
  public int hashCode() {
    return Objects.hash(this.datasetName, this.sourceTraceId, this.sourceObservationId, this.version, this.page, this.limit);
  }

  @java.lang.Override
  public String toString() {
    return ObjectMappers.stringify(this);
  }

  public static Builder builder() {
    return new Builder();
  }

  @JsonIgnoreProperties(
      ignoreUnknown = true
  )
  public static final class Builder {
    private Optional<String> datasetName = Optional.empty();

    private Optional<String> sourceTraceId = Optional.empty();

    private Optional<String> sourceObservationId = Optional.empty();

    private Optional<OffsetDateTime> version = Optional.empty();

    private Optional<Integer> page = Optional.empty();

    private Optional<Integer> limit = Optional.empty();

    @JsonAnySetter
    private Map<String, Object> additionalProperties = new HashMap<>();

    private Builder() {
    }

    public Builder from(GetDatasetItemsRequest other) {
      datasetName(other.getDatasetName());
      sourceTraceId(other.getSourceTraceId());
      sourceObservationId(other.getSourceObservationId());
      version(other.getVersion());
      page(other.getPage());
      limit(other.getLimit());
      return this;
    }

    @JsonSetter(
        value = "datasetName",
        nulls = Nulls.SKIP
    )
    public Builder datasetName(Optional<String> datasetName) {
      this.datasetName = datasetName;
      return this;
    }

    public Builder datasetName(String datasetName) {
      this.datasetName = Optional.ofNullable(datasetName);
      return this;
    }

    @JsonSetter(
        value = "sourceTraceId",
        nulls = Nulls.SKIP
    )
    public Builder sourceTraceId(Optional<String> sourceTraceId) {
      this.sourceTraceId = sourceTraceId;
      return this;
    }

    public Builder sourceTraceId(String sourceTraceId) {
      this.sourceTraceId = Optional.ofNullable(sourceTraceId);
      return this;
    }

    @JsonSetter(
        value = "sourceObservationId",
        nulls = Nulls.SKIP
    )
    public Builder sourceObservationId(Optional<String> sourceObservationId) {
      this.sourceObservationId = sourceObservationId;
      return this;
    }

    public Builder sourceObservationId(String sourceObservationId) {
      this.sourceObservationId = Optional.ofNullable(sourceObservationId);
      return this;
    }

    /**
     * <p>ISO 8601 timestamp (RFC 3339, Section 5.6) in UTC (e.g., &quot;2026-01-21T14:35:42Z&quot;).
     * If provided, returns state of dataset at this timestamp.
     * If not provided, returns the latest version. Requires datasetName to be specified.</p>
     */
    @JsonSetter(
        value = "version",
        nulls = Nulls.SKIP
    )
    public Builder version(Optional<OffsetDateTime> version) {
      this.version = version;
      return this;
    }

    public Builder version(OffsetDateTime version) {
      this.version = Optional.ofNullable(version);
      return this;
    }

    /**
     * <p>page number, starts at 1</p>
     */
    @JsonSetter(
        value = "page",
        nulls = Nulls.SKIP
    )
    public Builder page(Optional<Integer> page) {
      this.page = page;
      return this;
    }

    public Builder page(Integer page) {
      this.page = Optional.ofNullable(page);
      return this;
    }

    /**
     * <p>limit of items per page</p>
     */
    @JsonSetter(
        value = "limit",
        nulls = Nulls.SKIP
    )
    public Builder limit(Optional<Integer> limit) {
      this.limit = limit;
      return this;
    }

    public Builder limit(Integer limit) {
      this.limit = Optional.ofNullable(limit);
      return this;
    }

    public GetDatasetItemsRequest build() {
      return new GetDatasetItemsRequest(datasetName, sourceTraceId, sourceObservationId, version, page, limit, additionalProperties);
    }

    public Builder additionalProperty(String key, Object value) {
      this.additionalProperties.put(key, value);
      return this;
    }

    public Builder additionalProperties(Map<String, Object> additionalProperties) {
      this.additionalProperties.putAll(additionalProperties);
      return this;
    }
  }
}
