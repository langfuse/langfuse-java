/**
 * This file was auto-generated by Fern from our API Definition.
 */

package resources.metrics.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import core.ObjectMappers;
import java.lang.Object;
import java.lang.String;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(
    builder = UsageByModel.Builder.class
)
public final class UsageByModel {
  private final Optional<String> model;

  private final int inputUsage;

  private final int outputUsage;

  private final int totalUsage;

  private final int countTraces;

  private final int countObservations;

  private final double totalCost;

  private final Map<String, Object> additionalProperties;

  private UsageByModel(Optional<String> model, int inputUsage, int outputUsage, int totalUsage,
      int countTraces, int countObservations, double totalCost,
      Map<String, Object> additionalProperties) {
    this.model = model;
    this.inputUsage = inputUsage;
    this.outputUsage = outputUsage;
    this.totalUsage = totalUsage;
    this.countTraces = countTraces;
    this.countObservations = countObservations;
    this.totalCost = totalCost;
    this.additionalProperties = additionalProperties;
  }

  @JsonProperty("model")
  public Optional<String> getModel() {
    return model;
  }

  /**
   * @return Total number of generation input units (e.g. tokens)
   */
  @JsonProperty("inputUsage")
  public int getInputUsage() {
    return inputUsage;
  }

  /**
   * @return Total number of generation output units (e.g. tokens)
   */
  @JsonProperty("outputUsage")
  public int getOutputUsage() {
    return outputUsage;
  }

  /**
   * @return Total number of generation total units (e.g. tokens)
   */
  @JsonProperty("totalUsage")
  public int getTotalUsage() {
    return totalUsage;
  }

  @JsonProperty("countTraces")
  public int getCountTraces() {
    return countTraces;
  }

  @JsonProperty("countObservations")
  public int getCountObservations() {
    return countObservations;
  }

  /**
   * @return Total model cost in USD
   */
  @JsonProperty("totalCost")
  public double getTotalCost() {
    return totalCost;
  }

  @java.lang.Override
  public boolean equals(Object other) {
    if (this == other) return true;
    return other instanceof UsageByModel && equalTo((UsageByModel) other);
  }

  @JsonAnyGetter
  public Map<String, Object> getAdditionalProperties() {
    return this.additionalProperties;
  }

  private boolean equalTo(UsageByModel other) {
    return model.equals(other.model) && inputUsage == other.inputUsage && outputUsage == other.outputUsage && totalUsage == other.totalUsage && countTraces == other.countTraces && countObservations == other.countObservations && totalCost == other.totalCost;
  }

  @java.lang.Override
  public int hashCode() {
    return Objects.hash(this.model, this.inputUsage, this.outputUsage, this.totalUsage, this.countTraces, this.countObservations, this.totalCost);
  }

  @java.lang.Override
  public String toString() {
    return ObjectMappers.stringify(this);
  }

  public static InputUsageStage builder() {
    return new Builder();
  }

  public interface InputUsageStage {
    OutputUsageStage inputUsage(int inputUsage);

    Builder from(UsageByModel other);
  }

  public interface OutputUsageStage {
    TotalUsageStage outputUsage(int outputUsage);
  }

  public interface TotalUsageStage {
    CountTracesStage totalUsage(int totalUsage);
  }

  public interface CountTracesStage {
    CountObservationsStage countTraces(int countTraces);
  }

  public interface CountObservationsStage {
    TotalCostStage countObservations(int countObservations);
  }

  public interface TotalCostStage {
    _FinalStage totalCost(double totalCost);
  }

  public interface _FinalStage {
    UsageByModel build();

    _FinalStage model(Optional<String> model);

    _FinalStage model(String model);
  }

  @JsonIgnoreProperties(
      ignoreUnknown = true
  )
  public static final class Builder implements InputUsageStage, OutputUsageStage, TotalUsageStage, CountTracesStage, CountObservationsStage, TotalCostStage, _FinalStage {
    private int inputUsage;

    private int outputUsage;

    private int totalUsage;

    private int countTraces;

    private int countObservations;

    private double totalCost;

    private Optional<String> model = Optional.empty();

    @JsonAnySetter
    private Map<String, Object> additionalProperties = new HashMap<>();

    private Builder() {
    }

    @java.lang.Override
    public Builder from(UsageByModel other) {
      model(other.getModel());
      inputUsage(other.getInputUsage());
      outputUsage(other.getOutputUsage());
      totalUsage(other.getTotalUsage());
      countTraces(other.getCountTraces());
      countObservations(other.getCountObservations());
      totalCost(other.getTotalCost());
      return this;
    }

    /**
     * <p>Total number of generation input units (e.g. tokens)</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    @JsonSetter("inputUsage")
    public OutputUsageStage inputUsage(int inputUsage) {
      this.inputUsage = inputUsage;
      return this;
    }

    /**
     * <p>Total number of generation output units (e.g. tokens)</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    @JsonSetter("outputUsage")
    public TotalUsageStage outputUsage(int outputUsage) {
      this.outputUsage = outputUsage;
      return this;
    }

    /**
     * <p>Total number of generation total units (e.g. tokens)</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    @JsonSetter("totalUsage")
    public CountTracesStage totalUsage(int totalUsage) {
      this.totalUsage = totalUsage;
      return this;
    }

    @java.lang.Override
    @JsonSetter("countTraces")
    public CountObservationsStage countTraces(int countTraces) {
      this.countTraces = countTraces;
      return this;
    }

    @java.lang.Override
    @JsonSetter("countObservations")
    public TotalCostStage countObservations(int countObservations) {
      this.countObservations = countObservations;
      return this;
    }

    /**
     * <p>Total model cost in USD</p>
     * @return Reference to {@code this} so that method calls can be chained together.
     */
    @java.lang.Override
    @JsonSetter("totalCost")
    public _FinalStage totalCost(double totalCost) {
      this.totalCost = totalCost;
      return this;
    }

    @java.lang.Override
    public _FinalStage model(String model) {
      this.model = Optional.ofNullable(model);
      return this;
    }

    @java.lang.Override
    @JsonSetter(
        value = "model",
        nulls = Nulls.SKIP
    )
    public _FinalStage model(Optional<String> model) {
      this.model = model;
      return this;
    }

    @java.lang.Override
    public UsageByModel build() {
      return new UsageByModel(model, inputUsage, outputUsage, totalUsage, countTraces, countObservations, totalCost, additionalProperties);
    }
  }
}
